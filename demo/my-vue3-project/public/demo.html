<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
<script type="module">
  // case1 react
  //   var obj = {
  //     name: "fudx",
  //     age: 12,
  //   };
  //   const state = reactive(obj);
  //   const state2 = reactive(obj);
  //   console.log(state === state2)
  const proxyMap = new WeakMap();
  const targetMap = new WeakMap()
  const IS_REACTIVE = "is_reactive";
  const mutableHandler = {
    get(target, key, receiver) {
      if (key === IS_REACTIVE) return true;
      console.log(activeEffect)
      track(target,key)
      return Reflect.get(target, key, receiver)
    },
    set(target, key, value, receiver) {
        let oldValue  = target[key]
        console.log(oldValue,value)
        let result = Reflect.set(target, key, value,receiver)
        if( oldValue != value ) {
            trigger(target,key,oldValue,value)
        }
      return result
    },
  };
  function reactive(obj) {
    if (typeof obj === "object" && obj != null) {
      if (proxyMap.get(obj)) {
        return proxyMap.get(obj);
      }
      if (obj[IS_REACTIVE]) return obj;
      const proxyObj = new Proxy(obj, mutableHandler);
      proxyMap.set(obj, proxyObj);
      return proxyObj;
    }
    return obj;
  }
  // case2
  //   var obj = {
  //     name: "fudx",
  //     age: 12,
  //   };
  //   const state = reactive(obj);
  //   const state2 = reactive(state);
  //   console.log(state === state2)

  // case3
//   var obj = {
//     name: "fudx",
//     age: 12,
//     get ooo() {
//         console.log(this)
//         return 12 + this.age
//     }
//   };
//   const state = reactive(obj);
//   console.log(state);
//   console.log(state.age = 90);
//   console.log(state.ooo);
//   console.log(obj)
  // case4 为什么要用Reflect.get 和 Reflect.set get是怕死循环 set处理继承问题 并且有返回值true和false
  // effect
  let activeEffect
  let lastEffect
  function effect(fn) {
    const _effect = new ReactiveEffect(fn,()=>{
        _effect.run()
    })
    _effect.run()
    return _effect
  }
  class ReactiveEffect {
    active = true
    trackID = 0
    constructor (fn,scheduler) {
        this.fn = fn
        this.scheduler = scheduler
    }
    run() {
        if(!this.active) {
            return this.fn()
        }
        try {
            lastEffect = activeEffect
            activeEffect = this
            this.fn()
        } finally {
            activeEffect = lastEffect
        }
    }
  }

  var obj = {
    name: "fudx",
    age: 12,
    get ooo() {
        console.log(this)
        return 12 + this.age
    }
  };
  const state = reactive(obj);
  effect(()=>{
    app.innerHTML = `${state.name},我的年龄是${state.age}`
    // effect(()=>{
    //     console.log(state.name)
    // })
  })
  setTimeout(()=>{
    console.log(state.age++)
  },900)
  // 收集依赖
  function track(target,key) {
    if(!activeEffect)return
    let deps = targetMap.get(target)
    if(!deps) {
        targetMap.set(target,deps = new Map())
    }
    let dep = deps.get(key)
    if(!dep) {
        deps.set(key,dep = new Map())
    }
    dep.set(activeEffect,activeEffect.trackID)
    console.log(targetMap)
  }
  // 触发依赖
  function trigger(target,key,oldValue,value) {
    const deps = targetMap.get(target)
    if(deps) {
        let dep = deps.get(key)
        if(dep) {
            for(let effect of dep.keys()) {
                if(effect.scheduler) {
                    console.log(targetMap,'targetMap')
                    effect.scheduler()
                }
            }
        }
    }
  }
</script>
